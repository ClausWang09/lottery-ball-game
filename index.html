<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottery Ball Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .scoreboards {
            display: flex;
            gap: 100px;
            margin-bottom: 20px;
        }

        .scoreboard {
            width: 200px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            border: 3px solid #gold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .scoreboard.winner {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            animation: glow 1s ease-in-out infinite alternate;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px #FFD700; }
            to { box-shadow: 0 0 30px #FFA500, 0 0 40px #FFD700; }
        }

        .lottery-boxes {
            display: flex;
            gap: 80px;
            margin-bottom: 30px;
        }

        .lottery-box {
            width: 200px;
            height: 200px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .ball {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .ball.drawn {
            animation: floatAndExplode 3s ease-out forwards;
            z-index: 100;
        }

        @keyframes floatAndExplode {
            0% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
            70% {
                transform: scale(3) translateY(-150px);
                opacity: 1;
            }
            85% {
                transform: scale(3.5) translateY(-150px);
                opacity: 1;
            }
            100% {
                transform: scale(4) translateY(-150px);
                opacity: 0;
            }
        }

        @keyframes explosion {
            0% {
                transform: scale(3.5);
                opacity: 1;
            }
            50% {
                transform: scale(5);
                opacity: 0.8;
                box-shadow: 0 0 30px #FFD700, 0 0 60px #FF6B6B;
            }
            100% {
                transform: scale(8);
                opacity: 0;
                box-shadow: 0 0 50px #FFD700, 0 0 100px #FF6B6B;
            }
        }

        .ball.exploding {
            animation: explosion 0.5s ease-out forwards;
        }

        .controls {
            display: flex;
            gap: 20px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .draw-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .draw-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .draw-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .restart-btn {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .game-status {
            font-size: 24px;
            color: white;
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 30px;">Lottery Ball Game</h1>

        <div class="scoreboards">
            <div class="scoreboard" id="scoreboard1">?</div>
            <div class="scoreboard" id="scoreboard2">?</div>
            <div class="scoreboard" id="scoreboard3">?</div>
        </div>

        <div class="lottery-boxes">
            <div class="lottery-box" id="box1"></div>
            <div class="lottery-box" id="box2"></div>
            <div class="lottery-box" id="box3"></div>
        </div>

        <div class="controls">
            <button class="btn draw-btn" id="drawBtn">Start Drawing</button>
            <button class="btn draw-btn" id="continuousBtn">Continuous Draw</button>
            <button class="btn restart-btn" id="restartBtn">Restart Game</button>
        </div>

        <div class="game-status" id="gameStatus">Press "Start Drawing" to begin!</div>
    </div>

    <script>
        // Names from user.txt
        const names = [
            'Frank', 'Henry', 'Peter', 'Roger', 'David', 'Sean', 'Jill', 'Wendy',
            'Winyoung', 'Kris', 'Rick', 'Joey', 'Tyler', 'Jeffrey', 'Sylvia', 'Eddie', 'Hana', 'Jolie'
        ];

        let isDrawing = false;
        let gameEnded = false;
        let ballAnimations = [];
        let isContinuousMode = false;

        class Ball {
            constructor(name, boxElement) {
                this.name = name;
                this.boxElement = boxElement;
                this.element = document.createElement('div');
                this.element.className = 'ball';
                this.element.textContent = name.slice(0, 4); // Show first 4 chars
                this.element.title = name; // Full name on hover

                this.x = Math.random() * 150 + 25;
                this.y = Math.random() * 150 + 25;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';

                boxElement.appendChild(this.element);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x <= 0 || this.x >= 175) {
                    this.vx = -this.vx;
                    this.x = Math.max(0, Math.min(175, this.x));
                }
                if (this.y <= 0 || this.y >= 175) {
                    this.vy = -this.vy;
                    this.y = Math.max(0, Math.min(175, this.y));
                }

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
            }

            floatAndExplode(callback) {
                this.element.classList.add('drawn');

                // After floating animation completes (3 seconds), trigger explosion and callback
                setTimeout(() => {
                    this.element.classList.remove('drawn');
                    this.element.classList.add('exploding');

                    // Call callback to update scoreboard during explosion
                    if (callback) {
                        setTimeout(() => {
                            callback(this.name);
                        }, 100); // Show name slightly after explosion starts
                    }

                    // Remove element after explosion
                    setTimeout(() => {
                        if (this.element.parentNode) {
                            this.element.parentNode.removeChild(this.element);
                        }
                    }, 500); // Wait for explosion animation to complete
                }, 3000); // Wait for float animation to complete
            }
        }

        class LotteryBox {
            constructor(element) {
                this.element = element;
                this.balls = [];
                this.initBalls();
                this.animate();
            }

            initBalls() {
                // Clear existing balls
                this.element.innerHTML = '';
                this.balls = [];

                // Create balls for each name
                names.forEach(name => {
                    const ball = new Ball(name, this.element);
                    this.balls.push(ball);
                });
            }

            animate() {
                if (this.balls.length > 0) {
                    this.balls.forEach(ball => ball.update());
                }
                requestAnimationFrame(() => this.animate());
            }

            drawBall(callback) {
                if (this.balls.length === 0) return null;

                const randomIndex = Math.floor(Math.random() * this.balls.length);
                const drawnBall = this.balls.splice(randomIndex, 1)[0];

                // Return a promise that resolves when the animation completes
                return new Promise((resolve) => {
                    drawnBall.floatAndExplode((name) => {
                        if (callback) callback(name);
                        resolve(name);
                    });
                });
            }
        }

        // Initialize lottery boxes
        const box1 = new LotteryBox(document.getElementById('box1'));
        const box2 = new LotteryBox(document.getElementById('box2'));
        const box3 = new LotteryBox(document.getElementById('box3'));
        const boxes = [box1, box2, box3];

        const scoreboards = [
            document.getElementById('scoreboard1'),
            document.getElementById('scoreboard2'),
            document.getElementById('scoreboard3')
        ];

        const drawBtn = document.getElementById('drawBtn');
        const continuousBtn = document.getElementById('continuousBtn');
        const restartBtn = document.getElementById('restartBtn');
        const gameStatus = document.getElementById('gameStatus');

        function updateGameStatus(message) {
            gameStatus.textContent = message;
        }

        function checkWinner(results) {
            const counts = {};
            results.forEach(name => {
                counts[name] = (counts[name] || 0) + 1;
            });

            for (const [name, count] of Object.entries(counts)) {
                if (count >= 2) {
                    return name;
                }
            }
            return null;
        }

        function highlightWinner(winnerName, results) {
            scoreboards.forEach((scoreboard, index) => {
                if (results[index] === winnerName) {
                    scoreboard.classList.add('winner');
                }
            });
        }

        function hasRemainingBalls() {
            return boxes.some(box => box.balls.length > 0);
        }

        function clearScoreboards() {
            scoreboards.forEach(scoreboard => {
                scoreboard.textContent = '?';
                scoreboard.classList.remove('winner');
            });
        }

        async function drawSequence() {
            isDrawing = true;
            drawBtn.disabled = true;
            continuousBtn.disabled = true;
            const results = [];

            // If game ended (winner was found), clear scoreboards first
            if (gameEnded) {
                clearScoreboards();
                gameEnded = false;
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Check if any box can draw (has balls)
            const canDraw = boxes.some(box => box.balls.length > 0);
            if (!canDraw) {
                updateGameStatus('No balls left! Game over.');
                isDrawing = false;
                drawBtn.disabled = false;
                continuousBtn.disabled = false;
                return;
            }

            for (let i = 0; i < 3; i++) {
                updateGameStatus(`Drawing from box ${i + 1}...`);
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Use the new drawBall method that returns a promise
                const drawResult = boxes[i].drawBall((name) => {
                    // This callback will be called when the ball explodes
                    scoreboards[i].textContent = name;
                });

                if (drawResult) {
                    const drawnName = await drawResult;
                    results.push(drawnName);
                } else {
                    results.push('Empty');
                    scoreboards[i].textContent = 'Empty';
                }

                // Wait a bit before moving to next box
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Check for winner
            const winner = checkWinner(results);
            if (winner) {
                highlightWinner(winner, results);
                updateGameStatus(`ðŸŽ‰ Winner: ${winner}! Press Start Drawing to continue! ðŸŽ‰`);
                gameEnded = true;
                isContinuousMode = false;
            } else {
                if (isContinuousMode && hasRemainingBalls()) {
                    updateGameStatus('No winner this round. Continuing...');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    clearScoreboards();
                    await new Promise(resolve => setTimeout(resolve, 500));
                    // Continue with next round
                    drawSequence();
                    return;
                } else if (!hasRemainingBalls()) {
                    updateGameStatus('No balls left! Game over.');
                    isContinuousMode = false;
                } else {
                    updateGameStatus('No winner this round. Try again!');
                }
            }

            isDrawing = false;
            drawBtn.disabled = false;
            continuousBtn.disabled = false;
        }

        function restartGame() {
            // Reset game state
            isDrawing = false;
            gameEnded = false;
            isContinuousMode = false;
            drawBtn.disabled = false;
            continuousBtn.disabled = false;

            // Clear scoreboards
            clearScoreboards();

            // Reinitialize all boxes
            boxes.forEach(box => box.initBalls());

            updateGameStatus('Press "Start Drawing" to begin!');
        }

        // Event listeners
        drawBtn.addEventListener('click', () => {
            if (!isDrawing) {
                isContinuousMode = false;
                drawSequence();
            }
        });

        continuousBtn.addEventListener('click', () => {
            if (!isDrawing) {
                isContinuousMode = true;
                drawSequence();
            }
        });

        restartBtn.addEventListener('click', restartGame);

        // Initialize game status
        updateGameStatus('Press "Start Drawing" to begin!');
    </script>
</body>
</html>