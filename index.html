<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottery Ball Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .scoreboards {
            display: flex;
            gap: 100px;
            margin-bottom: 20px;
        }

        .scoreboard {
            width: 200px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            border: 3px solid #gold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .scoreboard.winner {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            animation: glow 1s ease-in-out infinite alternate;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px #FFD700; }
            to { box-shadow: 0 0 30px #FFA500, 0 0 40px #FFD700; }
        }

        .lottery-boxes {
            display: flex;
            gap: 80px;
            margin-bottom: 30px;
        }

        .lottery-box {
            width: 200px;
            height: 200px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .ball {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .ball.drawn {
            animation: floatAndExplode 3s ease-out forwards;
            z-index: 100;
        }

        @keyframes floatAndExplode {
            0% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
            70% {
                transform: scale(3) translateY(-150px);
                opacity: 1;
            }
            85% {
                transform: scale(3.5) translateY(-150px);
                opacity: 1;
            }
            100% {
                transform: scale(4) translateY(-150px);
                opacity: 0;
            }
        }

        @keyframes explosion {
            0% {
                transform: scale(3.5);
                opacity: 1;
            }
            50% {
                transform: scale(5);
                opacity: 0.8;
                box-shadow: 0 0 30px #FFD700, 0 0 60px #FF6B6B;
            }
            100% {
                transform: scale(8);
                opacity: 0;
                box-shadow: 0 0 50px #FFD700, 0 0 100px #FF6B6B;
            }
        }

        .ball.exploding {
            animation: explosion 0.5s ease-out forwards;
        }

        .controls {
            display: flex;
            gap: 20px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .draw-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .draw-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .draw-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .restart-btn {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .game-status {
            font-size: 24px;
            color: white;
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .main-content {
            display: flex;
            align-items: flex-start;
            gap: 40px;
            width: 100%;
            max-width: 1000px;
        }

        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .winners-panel {
            width: 300px;
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 2px solid rgba(255,215,0,0.6);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            position: relative;
        }

        .winners-header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .crown {
            font-size: 48px;
            margin-bottom: 10px;
            display: block;
            filter: drop-shadow(0 4px 8px rgba(255,215,0,0.4));
        }

        .winners-title {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 0;
        }

        .winners-list {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,215,0,0.5) transparent;
        }

        .winners-list::-webkit-scrollbar {
            width: 6px;
        }

        .winners-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .winners-list::-webkit-scrollbar-thumb {
            background: rgba(255,215,0,0.5);
            border-radius: 3px;
        }

        .winner-item {
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,165,0,0.1));
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 10px;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            animation: slideIn 0.5s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .winner-number {
            background: rgba(255,215,0,0.8);
            color: #333;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .no-winners {
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-style: italic;
            padding: 20px 0;
        }

        .participants-panel {
            width: 100%;
            max-width: 1000px;
            background: linear-gradient(145deg, rgba(135,206,250,0.1), rgba(100,149,237,0.05));
            border: 2px solid rgba(135,206,250,0.6);
            border-radius: 20px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }


        .participants-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(135,206,250,0.5) transparent;
        }

        .participants-list::-webkit-scrollbar {
            height: 6px;
        }

        .participants-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .participants-list::-webkit-scrollbar-thumb {
            background: rgba(135,206,250,0.5);
            border-radius: 3px;
        }

        .participant-item {
            background: linear-gradient(135deg, rgba(135,206,250,0.15), rgba(100,149,237,0.1));
            border: 1px solid rgba(135,206,250,0.3);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-size: 13px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-width: 120px;
            flex: 0 0 auto;
        }

        .participant-name {
            font-weight: bold;
            flex: 1;
        }

        .participant-probability {
            background: rgba(135,206,250,0.8);
            color: #333;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            min-width: 38px;
            text-align: center;
            margin-left: 8px;
        }

        .participant-item.eliminated {
            opacity: 0.4;
            background: linear-gradient(135deg, rgba(128,128,128,0.15), rgba(64,64,64,0.1));
            border-color: rgba(128,128,128,0.3);
        }

        .participant-item.eliminated .participant-probability {
            background: rgba(128,128,128,0.6);
            color: #666;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 15px;">Lottery Ball Game</h1>

        <div class="participants-panel">
            <div class="participants-list" id="participantsList">
                <!-- Participants will be populated by JavaScript -->
            </div>
        </div>

        <div class="main-content">
            <div class="game-area">
                <div class="scoreboards">
                    <div class="scoreboard" id="scoreboard1">?</div>
                    <div class="scoreboard" id="scoreboard2">?</div>
                    <div class="scoreboard" id="scoreboard3">?</div>
                </div>

                <div class="lottery-boxes">
                    <div class="lottery-box" id="box1"></div>
                    <div class="lottery-box" id="box2"></div>
                    <div class="lottery-box" id="box3"></div>
                </div>

                <div class="controls">
                    <button class="btn draw-btn" id="continuousBtn">Continuous Draw</button>
                    <button class="btn restart-btn" id="restartBtn">Restart Game</button>
                </div>

                <div class="game-status" id="gameStatus">Press "Continuous Draw" to begin!</div>
            </div>

            <div class="winners-panel">
                <div class="winners-header">
                    <span class="crown">👑</span>
                    <h2 class="winners-title">Winners Hall</h2>
                </div>
                <div class="winners-list" id="winnersList">
                    <div class="no-winners">No winners yet...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Names from user.txt
        const names = [
            'Frank', 'Henry', 'Peter', 'Roger', 'David', 'Sean', 'Jill', 'Wendy',
            'Winyoung', 'Kris', 'Rick', 'Joey', 'Tyler', 'Jeffrey', 'Sylvia', 'Eddie', 'Hana', 'Jolie'
        ];

        let isDrawing = false;
        let gameEnded = false;
        let ballAnimations = [];
        let isContinuousMode = false;
        let winnerCount = 0;
        let winners = [];

        // Get UI elements
        const winnersList = document.getElementById('winnersList');
        const participantsList = document.getElementById('participantsList');

        // Calculate winning probability for a participant
        function calculateWinningProbability(participantName) {
            // Get the probability of drawing this participant from each box
            const probabilities = [];

            for (let i = 0; i < 3; i++) {
                const box = boxes[i];
                const participantBalls = box.balls.filter(ball => ball.name === participantName).length;
                const totalBalls = box.balls.length;

                if (totalBalls === 0) {
                    probabilities.push(0);
                } else {
                    probabilities.push(participantBalls / totalBalls);
                }
            }

            // If no balls left for this participant in any box, probability is 0
            if (probabilities.every(p => p === 0)) return 0;

            const [p1, p2, p3] = probabilities;

            // Calculate P(at least 2 successes in 3 independent trials)
            // P(at least 2) = P(exactly 2) + P(exactly 3)

            // P(exactly 2) = P(success in boxes 1&2, fail in 3) +
            //                 P(success in boxes 1&3, fail in 2) +
            //                 P(success in boxes 2&3, fail in 1)
            const pExactly2 = (p1 * p2 * (1 - p3)) +
                             (p1 * (1 - p2) * p3) +
                             ((1 - p1) * p2 * p3);

            // P(exactly 3) = P(success in all 3 boxes)
            const pExactly3 = p1 * p2 * p3;

            // Total winning probability
            const totalProbability = pExactly2 + pExactly3;

            return Math.min(totalProbability * 100, 100); // Convert to percentage, cap at 100%
        }

        // Update participants list with current probabilities
        function updateParticipantsList() {
            participantsList.innerHTML = '';

            names.forEach(name => {
                const probability = calculateWinningProbability(name);
                const isEliminated = probability === 0;

                const participantDiv = document.createElement('div');
                participantDiv.className = `participant-item ${isEliminated ? 'eliminated' : ''}`;

                participantDiv.innerHTML = `
                    <span class="participant-name">${name}</span>
                    <span class="participant-probability">${probability.toFixed(1)}%</span>
                `;

                participantsList.appendChild(participantDiv);
            });
        }

        class Ball {
            constructor(name, boxElement) {
                this.name = name;
                this.boxElement = boxElement;
                this.element = document.createElement('div');
                this.element.className = 'ball';
                this.element.textContent = name.slice(0, 4); // Show first 4 chars
                this.element.title = name; // Full name on hover

                this.x = Math.random() * 150 + 25;
                this.y = Math.random() * 150 + 25;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';

                boxElement.appendChild(this.element);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x <= 0 || this.x >= 175) {
                    this.vx = -this.vx;
                    this.x = Math.max(0, Math.min(175, this.x));
                }
                if (this.y <= 0 || this.y >= 175) {
                    this.vy = -this.vy;
                    this.y = Math.max(0, Math.min(175, this.y));
                }

                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
            }

            floatAndExplode(callback) {
                this.element.classList.add('drawn');

                // After floating animation completes (3 seconds), trigger explosion and callback
                setTimeout(() => {
                    this.element.classList.remove('drawn');
                    this.element.classList.add('exploding');

                    // Call callback to update scoreboard during explosion
                    if (callback) {
                        setTimeout(() => {
                            callback(this.name);
                        }, 100); // Show name slightly after explosion starts
                    }

                    // Remove element after explosion
                    setTimeout(() => {
                        if (this.element.parentNode) {
                            this.element.parentNode.removeChild(this.element);
                        }
                    }, 500); // Wait for explosion animation to complete
                }, 3000); // Wait for float animation to complete
            }
        }

        class LotteryBox {
            constructor(element) {
                this.element = element;
                this.balls = [];
                this.initBalls();
                this.animate();
            }

            initBalls() {
                // Clear existing balls
                this.element.innerHTML = '';
                this.balls = [];

                // Create balls for each name
                names.forEach(name => {
                    const ball = new Ball(name, this.element);
                    this.balls.push(ball);
                });
            }

            animate() {
                if (this.balls.length > 0) {
                    this.balls.forEach(ball => ball.update());
                }
                requestAnimationFrame(() => this.animate());
            }

            drawBall(callback) {
                if (this.balls.length === 0) return null;

                const randomIndex = Math.floor(Math.random() * this.balls.length);
                const drawnBall = this.balls.splice(randomIndex, 1)[0];

                // Return a promise that resolves when the animation completes
                return new Promise((resolve) => {
                    drawnBall.floatAndExplode((name) => {
                        if (callback) callback(name);
                        resolve(name);
                    });
                });
            }
        }

        // Initialize lottery boxes
        const box1 = new LotteryBox(document.getElementById('box1'));
        const box2 = new LotteryBox(document.getElementById('box2'));
        const box3 = new LotteryBox(document.getElementById('box3'));
        const boxes = [box1, box2, box3];

        const scoreboards = [
            document.getElementById('scoreboard1'),
            document.getElementById('scoreboard2'),
            document.getElementById('scoreboard3')
        ];

        const continuousBtn = document.getElementById('continuousBtn');
        const restartBtn = document.getElementById('restartBtn');
        const gameStatus = document.getElementById('gameStatus');

        function updateGameStatus(message) {
            gameStatus.textContent = message;
        }

        function checkWinner(results) {
            const counts = {};
            results.forEach(name => {
                counts[name] = (counts[name] || 0) + 1;
            });

            for (const [name, count] of Object.entries(counts)) {
                if (count >= 2) {
                    return name;
                }
            }
            return null;
        }

        function highlightWinner(winnerName, results) {
            scoreboards.forEach((scoreboard, index) => {
                if (results[index] === winnerName) {
                    scoreboard.classList.add('winner');
                }
            });
        }

        function hasRemainingBalls() {
            return boxes.some(box => box.balls.length > 0);
        }

        function clearScoreboards() {
            scoreboards.forEach(scoreboard => {
                scoreboard.textContent = '?';
                scoreboard.classList.remove('winner');
            });
        }

        function addWinner(winnerName) {
            winnerCount++;
            winners.push({ name: winnerName, number: winnerCount });
            updateWinnersList();
        }

        function updateWinnersList() {
            if (winners.length === 0) {
                winnersList.innerHTML = '<div class="no-winners">No winners yet...</div>';
            } else {
                winnersList.innerHTML = winners.map(winner =>
                    `<div class="winner-item">
                        <span class="winner-number">${winner.number}</span>
                        <span>${winner.name}</span>
                    </div>`
                ).join('');
            }
        }

        function clearWinnersList() {
            winners = [];
            winnerCount = 0;
            updateWinnersList();
        }

        async function drawSequence() {
            isDrawing = true;
            continuousBtn.disabled = true;
            const results = [];

            // If game ended (winner was found), clear scoreboards first
            if (gameEnded) {
                clearScoreboards();
                gameEnded = false;
                // Update probabilities after clearing scoreboards
                updateParticipantsList();
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Check if any box can draw (has balls)
            const canDraw = boxes.some(box => box.balls.length > 0);
            if (!canDraw) {
                updateGameStatus('No balls left! Game over.');
                isDrawing = false;
                continuousBtn.disabled = false;
                return;
            }

            for (let i = 0; i < 3; i++) {
                updateGameStatus(`Drawing from box ${i + 1}...`);
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Use the new drawBall method that returns a promise
                const drawResult = boxes[i].drawBall((name) => {
                    // This callback will be called when the ball explodes
                    scoreboards[i].textContent = name;
                });

                if (drawResult) {
                    const drawnName = await drawResult;
                    results.push(drawnName);
                } else {
                    results.push('Empty');
                    scoreboards[i].textContent = 'Empty';
                }

                // Update probabilities after each ball is drawn
                updateParticipantsList();

                // Wait a bit before moving to next box
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Check for winner
            const winner = checkWinner(results);
            if (winner) {
                highlightWinner(winner, results);
                addWinner(winner);
                updateGameStatus(`🎉 Winner: ${winner}! Press Continuous Draw to continue! 🎉`);
                gameEnded = true;
                isContinuousMode = false;
            } else {
                if (isContinuousMode && hasRemainingBalls()) {
                    updateGameStatus('No winner this round. Continuing...');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    clearScoreboards();
                    // Update probabilities before next round
                    updateParticipantsList();
                    await new Promise(resolve => setTimeout(resolve, 500));
                    // Continue with next round
                    drawSequence();
                    return;
                } else if (!hasRemainingBalls()) {
                    updateGameStatus('No balls left! Game over.');
                    isContinuousMode = false;
                } else {
                    updateGameStatus('No winner this round. Try again!');
                }
            }

            isDrawing = false;
            continuousBtn.disabled = false;

            // Update probabilities after drawing round
            updateParticipantsList();
        }

        function restartGame() {
            // Reset game state
            isDrawing = false;
            gameEnded = false;
            isContinuousMode = false;
            continuousBtn.disabled = false;

            // Clear scoreboards
            clearScoreboards();

            // Clear winners list
            clearWinnersList();

            // Reinitialize all boxes
            boxes.forEach(box => box.initBalls());

            // Update probabilities after restart
            updateParticipantsList();

            updateGameStatus('Press "Continuous Draw" to begin!');
        }

        // Event listeners
        continuousBtn.addEventListener('click', () => {
            if (!isDrawing) {
                isContinuousMode = true;
                drawSequence();
            }
        });

        restartBtn.addEventListener('click', restartGame);

        // Initialize game status and participants list
        updateGameStatus('Press "Continuous Draw" to begin!');
        updateParticipantsList();
    </script>
</body>
</html>